def main() {
  intr_en(zero)
  a = label_trap_handler
  intr_trap(a)
  call(vt100_mode)
  call(init_game)
  call(print_board)
  a = 1
  intr_en(a)
  halt()
}

def vt100_mode() {
  call(putchar, 27)
  call(putchar, 91)
  call(putchar, 50)
  call(putchar, 48)
  call(putchar, 104)
}

def init_game() {
  push(a,b,i)
  for (i=0; i<16; i=i+1) {
    mem[i] = zero
  }
  a = 4093
  b = 16
  mem[b] = a
  call(add_new)
  pop(i,b,a)
}

def trap_handler() {
  push(a,b,c,d,e,i)
  a = keyboard()
  b = 1
  intr_ack(b)

  for (i=0; i<16; i=i+1) {
    c = mem[i]
    sp = sp - 1
    mem[sp] = c
  }

  if (a == 119) {
    call(move_up)
  }
  if (a == 115) {
    call(move_down)
  }
  if (a == 97) {
    call(move_left)
  }
  if (a == 100) {
    call(move_right)
  }

  e = 0
  for (i=15; i>=0; i=i-1) {
    c = mem[i]
    d = mem[sp]
    sp = sp + 1
    if (c != d) {
      e = 1
    }
  }

  if (e != 0) {
    call(init_if_game_over)
    call(add_new)
    call(print_board)
  }

  pop(i,e,d,c,b,a)
  iret()
}

def putchar() {
  push(a,b)
  b = 1
  for (;b == 1;) {
    b = monitor_busy()
  }
  monitor(a)
  pop(b,a)
}

def print_board() {
  push(a,b,c,d,e,i)
  call(print_line)
  
  for (i=0; i<4; i=i+1) {
    call(putchar, 124)

    b = i << 2
    for (c=0; c<4; c=c+1) {
      call(putchar, 32)

      d = b + c
      e = mem[d]
      a = e + 48
      if (e == 0) {
        a = 32
      }
      call(putchar)

      call(putchar, 124)
    }
    call(putchar, 10)
    call(print_line)
  }
  call(putchar, 10)
  pop(i,e,d,c,b,a)
}

def print_line() {
  push(a,i)
  a = 45
  for (i=0; i<13; i=i+1) {
    call(putchar)
  }
  call(putchar, 10)
  pop(i,a)
}

def add_new() {
  push(a,b,c,d,e,f)
  f = 1
  call(rand)
  for (b=0; b<16; b=b+1) {
    c = a + b
    d = 15
    d = c & d
    e = mem[d]
    if (e == 0) {
      mem[d] = f
      f = 0
    }
  }
  pop(f,e,d,c,b,a)
}

def init_if_game_over() {
  push(a,b,c)
  a = 1
  for (b=0; b<16; b=b+1) {
    c = mem[b]
    if (c == 0) {
      a = 0
    }
  }
  if (a == 1) {
    call(init_game)
  }
  pop(c,b,a)
}

def rand() {
  push(b,c)
  c = 16
  a = mem[c]

  b = a << 13
  a = a ^ b

  b = a >> 17
  a = a ^ b

  b = a << 5
  a = a ^ b

  mem[c] = a
  pop(c,b)
}

def compress() {
  push(a,b,c,d,e,f,h)
  for (a=0; a<4; a=a+1) {
    b = a << 2
    h = 0
    for (c=0; c<4; c=c+1) {
      d = b + c
      e = mem[d]
      if (e != 0) {
        f = b + h
        mem[f] = e
        if (h != c) {
          mem[d] = zero
        }
        h = h + 1
      }
    }
  }
  pop(h,f,e,d,c,b,a)
}

def merge() {
  push(a,b,c,d,e,f,g)
  for (a=0; a<4; a=a+1) {
    b = a << 2
    for (c=0; c<3; c=c+1) {
      d = b + c
      e = mem[d]
      if (e != 0) {
        f = d + 1
        g = mem[f]
        if (e == g) {
          e = e + 1
          mem[d] = e
          mem[f] = zero
        }
      }
    }
  }
  pop(g,f,e,d,c,b,a)
}

def reverse() {
  push(a,b,c,d,e,f,g)
  for (a=0; a<4; a=a+1) {
    b = a << 2
    for (c=0; c<2; c=c+1) {
      d = b + c
      e = mem[d]
      f = b - c
      f = f + 3
      g = mem[f]
      mem[d] = g
      mem[f] = e
    }
  }
  pop(g,f,e,d,c,b,a)
}

def transpose() {
  push(a,b,c,d,e,f,g)
  for (a=0; a<4; a=a+1) {
    b = a << 2
    for (c=0; c<4; c=c+1) {
      if (a < c) {
        d = b + c
        e = mem[d]
        f = c << 2
        f = f + a
        g = mem[f]
        mem[d] = g
        mem[f] = e
      }
    }
  }
  pop(g,f,e,d,c,b,a)
}

def move_left() {
  call(compress)
  call(merge)
  call(compress)
}

def move_right() {
  call(reverse)
  call(move_left)
  call(reverse)
}

def move_up() {
  call(transpose)
  call(move_left)
  call(transpose)
}

def move_down() {
  call(transpose)
  call(move_right)
  call(transpose)
}
